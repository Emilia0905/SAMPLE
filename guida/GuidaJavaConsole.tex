\documentclass[a4paper,12 pt]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{booktabs}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{statrep}
\usepackage{emptypage}
\usepackage{newlfont}
\usepackage{enumerate}
\usepackage[hidelinks]{hyperref}
\usepackage[pass]{geometry}
\usepackage{titling}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{color}
	
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
	
\lstset{
		language=Java,
		aboveskip=7mm,
		belowskip=7mm,
		showstringspaces=false,
		columns=flexible,
		basicstyle={\small\ttfamily},
		numbers=none,
		numberstyle=\tiny\color{gray},
		keywordstyle=\color{blue},
		commentstyle=\color{dkgreen},
		stringstyle=\color{mauve},
		breaklines=false,
		breakatwhitespace=true,
		tabsize=3
	}
\pagestyle{plain}

\title{Guida Java Console}
\author{Vittorio Valent \& Davide Ferretti}
\date{Giugno 2019}

\begin{document}
	\thispagestyle{empty}
	\begin{center}
		\includegraphics[height=4cm]{Logo.png}
	\end{center}
	
	\maketitle
	\newpage
	\tableofcontents
	\newpage
	\section{Introduzione a Java}
	In questa breve guida esporremo le basi di Java e dei pattern utilizzati nel Training in Contrader. Questa guida non è una guida ufficiale ma solo un aiuto per coloro che si trovano in difficoltà all'inizio della loro esperienza da programmatori. Raccomandiamo di leggere attentamente il codice e i commenti (i quali rimandano proprio a questa guida). Per ogni domanda o suggerimento di ampliamento/modifica a questa guida potete mandare contattarci a\\
	
	\begin{itemize}
		\item  d.ferretti@contrader.it
		\item  v.valent@contrader.it
	\end{itemize}
	
	\noindent Java è un linguaggio di programmazione ad alto livello, orientato agli oggetti e a tipizzazione statica, che si appoggia sull'omonima piattaforma software, specificamente progettato per essere il più possibile indipendente dalla piattaforma hardware di esecuzione (tramite compilazione in bytecode prima e interpretazione poi da parte di una JavaVirtualMachine o JVM).\\
	
	\noindent Un programma minimale in Java deve obbligatoriamente contenere la definizione di classe tramite la parola chiave class seguita dal \textit{nomeclasse} e il metodo \textit{main} o metodo principale nonché entry point del programma in cui vengono definite variabili globali, oggetti e richiamati metodi statici su variabili e/o dinamici sugli oggetti.\\
	
	\begin{lstlisting}
		 class HelloWorld {
			public static void main(String[] args)
			{
				System.out.println("Hello World");
			}
		}
	\end{lstlisting}

	\noindent Nell'esempio soprastante il main contiene l'istruzione per la stampa a video della stringa Hello World; pur essendo perfettamente funzionante e semplice da comprendere, non viene sfruttata la filosofia ad oggetti che viene normalmente applicata ad ogni programma scritto in Java.\\
	Segue il codice sorgente di un programma che svolge lo stesso compito del precedente usando la programmazione orientata agli oggetti.
		\begin{lstlisting}
			public class Messaggio {
				private String toPrint;
			
				public Messaggio(String print) {
					this.toPrint = print;
				}
			
				public void print() {
					System.out.println(this.toPrint);
				}
			
				public static void main(String args[]) {
					Messaggio ciaoMondo = new Messaggio("Hello World!");
					ciaoMondo.print();
				}
			}
	\end{lstlisting}
	
	\noindent Il metodo main affida la stampa del messaggio a un oggetto creato apposta per questo compito, su cui è invocato il metodo dinamico \textit{print} definito prima del main assieme al costruttore della classe ovvero quel particolare metodo (con ugual nome della classe) che serve per inizializzare l'attributo della classe toPrint dell'oggetto creato/istanziato nel main.\\ I metodi definibili possono essere dichiarati \textit{privati} (contrassegnati dalla parola chiave private) se richiamabili solo all'interno della stessa classe oppure\textit{ pubblici} (contrassegnati dalla parola chiave \textit{public}) se richiamabili anche da altre classi, di tipo \textit{statico} (contrassegnati dalla parola chiave \textit{static}) se invocabili liberamente all'interno della classe (ad es. su variabili globali), dinamici se invocabili su oggetti.\\
	
	\noindent Scrivendo nuove classi che supportano l'operazione print, si può adattare il programma per mostrare messaggi di tipi radicalmente diversi, lasciando il main pressoché immutato, cambiando soltanto la metà riga che segue il new. Per esempio si può considerare un messaggio la scritta in una finestra che appare sullo schermo del computer in uso, oppure una stringa inviata su connessione di rete per apparire sulla finestra di un computer client. Oppure il programma può dialogare con l'utente sulla riga di comando (Java Console) o in una finestra (considerando il dialogo come un "messaggio interattivo").	
	
	\section{Classi e Oggetti}
	
	Java è un linguaggio\textit{ object-oriented}. L'idea che sta alla base della OOP è di rappresentare le entità reali o astratte che determinano le dinamiche del problema risolto dal software sotto forma di entità unitarie, dotate di specifiche d'uso e di funzionamento definite a priori. Queste entità sono chiamate \textit{oggetti}. Le specifiche che definiscono le caratteristiche di queste unità e in base a cui le stesse vengono create o, in gergo, \textit{istanziate}, sono chiamate classi.\\
	
	\noindent Java tuttavia non è un linguaggio ad oggetti puro, ma solamente object oriented (orientato agli oggetti): per esempio i valori dei tipi primitivi, come ad esempio \texttt{int}, \texttt{char} e \texttt{float},  non sono oggetti.
	
	\noindent Ogni classe di Java deve essere in un file separato che ha lo stesso nome della classe.È convenzione inoltre che i nomi delle classi comincino con la maiuscola, ed è bene rispettare questa prassi, per la leggibilità del codice, anche se non è obbligatoria. All'interno di una classe troveremo dei \textit{campi}, ovvero gli attributi della classe, uno o più costruttori per istanziare oggetti di questa classe ed eventualmente dei metodi (funzioni). \\
	
	\section{Metodi}
	
	Un metodo è un blocco di istruzioni che una classe o un oggetto rendono disponibili ad altre classi e/o oggetti, affinché possa essere eseguito su richiesta. \\
	In questo esempio, la JVM invoca il metodo main(), e questo metodo invoca il metodo scrivi(), il quale scrive una determinata stringa sulla console.
	
	\begin{lstlisting}
		public class Prova {
		
		public static void main(String[] args) {
		scrivi();
		}
		
		void scrivi() {
		System.out.println("prova");
		}
		
		}
	\end{lstlisting}
	\subsection{Composizione del metodo}
		L'intestazione di un metodo è definita da:
		\begin{itemize}
			\item eventuali modificatori
			\item tipo di ritorno
			\item nome del metodo
			\item lista di argomenti
		\end{itemize}
		I metodi sono utili perché permettono di definire dei "pacchetti" di istruzioni che vengono \textbf{eseguiti da un certo oggetto} su richiesta:
		
		\begin{lstlisting}
		public class Cane {
			
		public void abbaia() { System.out.println("Bau bau"); }
		public void dormi() { System.out.println("zzz"); }
			
		}
		
		public class Prova {
			public static void main(String[] args) {
			
			 	Cane c = new Cane();
			 	
				c.dormi();
				c.abbaia();
			}
		}
		
		\end{lstlisting}
	\subsection{Definire un metodo}
		La sintassi per la implementazione (scrittura di codice) di un metodo è la seguente:
		\begin{lstlisting}
			modificatori tipo nomedelmetodo (parametri eventuali) {
			corpo del metodo;
		}
	
		\end{lstlisting}
		
		I parametri possono esserci oppure no.
		
		\noindent I metodi possono restituire un valore particolare al chiamante oppure no.\\ Quando si vuole restituire un valore il chiamante diverrà tale valore. La restituzione di un valore si ha con l'enunciato "return" ed il tipo del valore restituito indicato prima del nome del metodo. Se non si vuole restituire un valore o un dato particolare allora non occorre return e prima del nome del metodo c'è bisogno dell'enunciato "void". \\ Quindi, prima del nome del metodo, ci deve essere o il "void" o il tipo del valore (con all'interno del corpo la clausola "return").
		
	\section{Pattern MVC}
	
		Model-View-Controller (MVC), in informatica, è un pattern architetturale molto diffuso nello sviluppo di sistemi software, in particolare nell'ambito della programmazione orientata agli oggetti, in grado di separare la logica di presentazione dei dati dalla logica di business.
		
		\subsection{Componenti}
			Il componente centrale del MVC, il \textbf{Model}, cattura il comportamento dell'applicazione in termini di dominio del problema, indipendentemente dall'interfaccia utente. Il Model gestisce direttamente i dati (tramite il DAO) e le regole dell'applicazione con il Model (un'interessante metonimia che spesso genera confusione). \\
			
			\noindent Una \textbf{View} può essere una qualsiasi rappresentazione in output di informazioni, come ad esempio la stampa in Java Console. Sono possibili viste multiple delle stesse informazioni.\\
			
			\noindent La terza parte, il \textbf{Controller}, accetta l'input e lo converte in comandi per il Model e/o la Vista. Nel nostro caso è supportato da un Service che funge da collegamento con il Model.\\
		
		\subsection{Funzionamento}
			L'utente si interfaccia sempre con la View, che tramite un server web (nel nostro caso il famigerato \textit{MainDispatcher}, vedi il codice) che invia i dati e gli input al controller tramite \textit{Request} (pacchetti di informazioni a struttura chiave-valore, vedi codice).\\
			Il Controller usa i metodi del Service per ottenere ed elaborare i dati da rimandare alla View \textbf{sempre tramite Request}.\\
			
			\noindent Il Model infine definisce le entità dell'applicazione (nel Model, stessa confusione di prima) e interagisce con il \textit{Database}, recuperando e modificando i dati.\\
			
			\noindent Qui mostriamo in un diagramma le interazioni nel pattern MVC:\\
			
			
				\begin{center}
				\includegraphics[height=8cm]{mvc.png}
			\end{center}
			
		
	\section{Model}
		Nel pacchetto model sono descritte tutte le entità dell'applicazione, ciascuna in una diversa classe. Ogni classe/entità possiede degli attributi, uno o più costruttori (in base al numero di argomenti), i metodi di accesso ai dati (Getter e Setter), un metodo per stampare l'oggetto in console (toString) e un metodo per il confronto degli oggetti (equals).\\
		In seguito analizziamo pezzo a pezzo le componenti della classe User del progetto SAPLEJava.
		\subsection{Attributi}
			I campi contrassegnati dal modificatore di accesso \texttt{private} sono i cosiddetti \textit{attributi} dell'entità. Avendo noi a che fare con un'entità di tipo User, avremo uno username, una password e un tipo di utente. Aggiungiamo inoltre un'id da usare come chiave privata sul database.\\
			
			\begin{lstlisting}
				package it.contrader.model;
			
				public class User {
				
					private int id;
					
					private String username;
					
					private String password;
					
					private String usertype;
				
			\end{lstlisting}
			\subsection{Costruttore}
			Di seguito troviamo i due costruttori, uno per istanziare un oggetto senza attributi e uno che invece lo istanzia con tutti gli attributi (tranne l'id).
				\begin{lstlisting}
					public User() {
						// costruttore vuoto
					}
					
					public User (String username, String password, String usertype) {
						this.username = username;
						this.password = password;
						this.usertype = usertype;
					}
				
				\end{lstlisting}
				
			\subsection{Getter e Setter}
			I metodi Getter e Setter servono alle altre classi ad accedere e modificare gli attributi di un oggetto. Infatti, a causa del modificatore di accesso \texttt{private}, le altre classi non potrebbero normalmente accedere a questi campi. Ci sono quindi due metodi per ogni attributo.\\
			 Il metodo get() non prende in pasto parametri e ritorna l'attributo.\\
			  Il metodo set(\textit{attributo}) non ha valore di ritorno e inserisce ( o sovrascrive) l'attributo all'interno dell'oggetto.
				\begin{lstlisting}
	
				public int getId() {
					return this.id;
				}
				public void setId(int id) {
					this.id = id;
				}
				
				public String getUsertype() {
					return this.usertype;
				}
				
				public void setUsertype(String usertype) {
					this.usertype = usertype;
				}
				
				public String getPassword() {
					return this.password;
				}
				
				public void setPassword(String password) {
					this.password = password;
				}
				
				public void setUsername(String username) {
					this.username = username;
				}
				
				public String getUsername() {
					return username;
				}
				\end{lstlisting}
				
				\subsection{ToString e Equals}
				
				Il metodo toString() restituisce l'oggetto trasformandolo in una stringa pronto alla stampa in Console. Il metodo equals controlla se due oggetti sono uguali (non essendo tipi primitivi non possono essere confrontati con un semplice '=='). Le annotazioni @Override segnala alla classe che i metodi devono sostituire i codici precedentemente presenti nei metodi (equals e toString sono presenti nella superclasse di User: Object).
				\begin{lstlisting}
				@Override
				public String toString() {
					return  id + "\t"  + username +"\t\t" +   password + "\t\t" + usertype;
				}
				
				@Override
				public boolean equals(Object obj) {
					if (this == obj)
					return true;
					if (obj == null)
					return false;
					if (getClass() != obj.getClass())
					return false;
					User other = (User) obj;
					if (id != other.id)
					return false;
					if (password == null) {
						if (other.password != null)
						return false;
					} else if (!password.equals(other.password))
					return false;
					if (username == null) {
						if (other.username != null)
						return false;
					} else if (!username.equals(other.username))
					return false;
					if (usertype == null) {
						if (other.usertype != null)
						return false;
					} else if (!usertype.equals(other.usertype))
					return false;
					return true;
				}
			}
			\end{lstlisting}
	
	
	\section{DAO}
	
	\section{Service}
	
	\section{Controller}
	
	\section{View}
	
	\section{Pattern Singleton}
	
	
\end{document}